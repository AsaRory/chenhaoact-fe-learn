# 模块Module

## 一 简介
ES6之前，Js 一直没有模块（module）体系，对开发大型、复杂项目形成了巨大障碍。

社区制定了一些模块加载方案，主要有 **CommonJS 和 AMD。前者用于服务器，后者用于浏览器**。

**ES6** 在语言标准上，实现了**模块功能，成为浏览器和服务器通用的模块解决方案**。

### 1. ES6 Module和 commonjs、AMD的对比
#### （1）静态化
**ES6 模块的设计思想，是尽量静态化，编译时就能确定模块的依赖关系，及输入和输出的变量**。**CommonJS 和 AMD 模块，都只能在运行时确定这些**。

比如CommonJS的加载为“运行时加载”，只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

ES6的import，不能“动态”拼一个路径，因为ES6的模块化就是**强制静态化**。

**ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入**。



```
// ES6模块
import { stat, exists, readFile } from 'fs';
```



上面代码实质是从fs模块加载 3 个方法，其他方法不加载。

这种加载**称为“编译时加载”或静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 高**。

由于 ES6 模块是**编译时加载，使得静态分析成为可能**。有了它，就能进一步拓宽 Js 的语法，如引入宏（macro）和**类型检验**（type system）这些只能靠静态分析实现的功能。


附：如果还是要动态引入模块：
如要动态引入模块，建议用node(commonjs)的require。require动态引入模块路径 require()里直接放url变量会报错: Cannot find module "."， 可先加带.的路径前缀的字符串再+文件路径变量即可，如：

```
const MdUrl = 'data/' + this.props.params.id + '.md';
const MdHtml = require('../../' + MdUrl);
```

import和require的对比参考：
Node中没搞明白require和import，你会被坑的很惨
http://www.tuicool.com/articles/uuUVBv2

#### （2）ES6 模块的好处

1. 静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 高。

2.。编译时加载，使得**静态分析**成为可能。能实现**类型检验这些只能靠静态分析实现的功能。**

**除了静态加载带来的各种好处，ES6 模块还有以下好处：**

3. 不再需要UMD模块格式，将来**服务器和浏览器都会支持 ES6 模块格式**。目前通过工具库其实已做到。
**将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性，这样会更加灵活**。

4. 不再需要对象作为命名空间（如Math对象），未来这些功能可以通过模块提供。


## 二 语法




### 如何在浏览器和 Node 之中，加载 ES6 模块？




