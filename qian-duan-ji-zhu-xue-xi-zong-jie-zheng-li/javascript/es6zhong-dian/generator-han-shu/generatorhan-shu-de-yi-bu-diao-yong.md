# Generator函数的异步应用

## 作用
异步编程对 JS 语言太重要。Js 语言的执行环境是“单线程”的，没有异步编程，根本没法用，非卡死不可。

## 传统方法

ES6 诞生以前，异步编程的方法，大概有下面四种。

回调函数
事件监听
发布/订阅
Promise 对象

Generator 函数将 Js 异步编程带入了一个全新的阶段。

## 基本概念 
### 异步
所谓"异步"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，比如操作系统从硬盘读取文件的这段时间，程序只能干等着。



### Generator 函数
Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。

**Generator 函数遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样**。


Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，**它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制**。

**next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据**。


Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。



```
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw('出错了');
// 出错了
```

上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。

## co 模块简介
co 模块用于 Generator 函数的自动执行。

Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

两种方法可以做到这一点。

（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。

（2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。

co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。


## 参考
ECMAScript 6 入门 - Generator 函数的异步应用
http://es6.ruanyifeng.com/#docs/generator-async



