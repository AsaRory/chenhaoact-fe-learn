### 事件

React使用小驼峰命名规范\(camelCase\)给组件绑定事件处理器。

把回调函数作为属性，无论事件什么时候触发，回调函数都将被调用。

#### （1）事件处理与合成事件系统

React 里只需把事件处理器（event handler）以骆峰命名形式当作组件的 props 传入即可，就像使用普通 HTML 那样。**React 内部创建一套合成事件系统**来**使所有事件在 IE8以上及其他的各种浏览器表现一致**。React 知道如何冒泡和捕获事件，而且你的事件处理器接收到的 events 参数与 [W3C 事件规范](https://www.w3.org/TR/DOM-Level-3-Events/) 一致，无论你使用哪种浏览器。

完备的**合成事件系统，使得所有的事件对象都被保证符合W3C细则，并且所有事件在各个浏览器都一致并高效的冒泡**（bubbles）。

#### （2）自动绑定和事件代理

在幕后，React的事件系统做了一些操作来让代码高效运行且易于理解。

**自动绑定**: 在 JS 里创建回调的时候，为了保证 this 的正确性，一般都需要显式地绑定方法到它的实例上。**在 React 中，所有方法被自动绑定到了它的组件实例上**（[除非使用ES6的class符号](http://www.react-cn.com/docs/reusable-components.html#no-autobinding)）。**React 还缓存这些绑定方法，所以 CPU 和内存都是非常高效**。而且还能减少打字！

**事件代理**: **React 并没有把事件处理器绑定到节点本身**。当 **React 启动时，会在最外层使用唯一一个事件监听器处理所有事件**。当组件被加载和卸载时，只是在内部映射里添加或删除事件处理器。当**事件触发，React 根据映射来决定如何分发**。当映射里没有事件处理函数时，会当作空操作处理。参考 [David Walsh 这篇很棒的文章](https://davidwalsh.name/event-delegate) 了解这样做高效的原因。

