### 组件的state

#### （1）state基础

基于自己的props，每个组件都渲染了自己一次。`props`是不可变的：它们从父级传来并被父级“拥有”。为了实现交互，给组件引进了可变的**state**。`this.state`是组件私有的，可以通过调用`this.setState()`改变它。每当state更新，组件就重新渲染自己。

`getInitialState()`在生命周期里只执行一次，并设置组件的初始状态。

#### （2）组件其实是状态机

**React 把用户界面当作简单状态机**。把用户界面想像成**拥有不同状态然后渲染这些状态，可以轻松让用户界面和数据保持一致**。

**React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。React 来决定如何最高效地更新 DOM。**

#### （3）State 工作原理

**常用的通知 React 数据变化的方法是调用 setState**\(data, callback\)。这个方法会合并（merge） data 到 this.state，并重新渲染组件。重新渲染完成后，调用可选的 callback 回调。**大部分情况下不需要提供 callback，因为 React 会负责把界面更新到最新状态**。

#### （4）哪些 应该 作为 State？哪些 不应该 作为 State？

**State 应该包括：**  
**那些可能被组件的事件处理器改变并触发用户界面更新的数据。** 真实的应用中这种数据一般都很小且能被 JSON 序列化。当创建一个状态化的组件时，思考一下表示它的状态最少需要哪些数据，并只把这些数据存入 this.state。在 render\(\) 里再根据 state 来计算你需要的其它数据。你会发现以这种方式思考和开发程序最终往往是正确的，因为如果在 state 里添加冗余数据或计算所得数据，那么你就需要经常手动保持数据同步，而不能让 React 来帮你处理。

**哪些 不应该 作为 State：**  
this.state 应该仅包括能表示用户界面状态所需的最少数据。因此，它不应该包括：

**计算所得数据**： 不要担心根据 state 来预先计算数据 —— **把所有的计算都放到 render\(\) 里**更容易保证用户界面和数据的一致性。例如，在 state 里有一个数组（listItems），我们要把数组长度渲染成字符串， 直接在 render\(\) 里使用 this.state.listItems.length + ' list items' 比把它放到 state 里好的多。  
**React 组件**： 在 render\(\) 里使用当前 props 和 state 来创建它。  
**基于 props 的重复数据**： 尽可能使用 props 来作为实际状态的源。把 props 保存到 state 的一个有效的场景是需要知道它以前值的时候，因为 props 可能因为父组件的重绘而变化。

#### （5）确定最小（但完备）的 UI state

需要思考你的 app 需要的可变 state 的最小组。这里的关键是 DRY 原则：_Don't Repeat Yourself\(不要重复自己\)_。想出哪些是你的应用需要的绝对最小 state 表达，并按需计算其他任何数据。

逐个检查出哪一个是state，只需要简单地问以下三个问题:

1. 它是通过props从父级传递来的吗？如果是，它可能不是 state。
2. 它随时间变化吗？如果不是,它可能不是 state。
3. 你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state. 

#### （6）确定 state 应该存在于哪里

React 总是在组件层级中单向数据流动的。可能不能立刻明白哪些组件应该拥有哪些 state。**这对于新手在理解上经常是最具挑战的一部分，**所以跟着这几步来弄明白它：

对于你的应用里每一个数据块：

* 确定哪些组件要基于 state 来渲染内容。
* 找到一个共同的拥有者组件（在所有需要这个state组件的层次之上，找出共有的单一组件）。
* 要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state。
* 如果你不能找到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上。

