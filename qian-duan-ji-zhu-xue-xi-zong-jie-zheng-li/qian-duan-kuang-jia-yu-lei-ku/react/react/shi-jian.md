# 事件

React使用小驼峰命名规范\(camelCase\)给组件绑定事件处理器。

把回调函数作为属性，无论事件什么时候触发，回调函数都将被调用。

## （1）事件处理与合成事件系统

React 里只需把事件处理器（event handler）以骆峰命名形式当作组件的 props 传入即可，就像使用普通 HTML 那样。**React 内部创建一套合成事件系统**来**使所有事件在 IE8以上及其他的各种浏览器表现一致**。React 知道如何冒泡和捕获事件，而且你的事件处理器接收到的 events 参数与 [W3C 事件规范](https://www.w3.org/TR/DOM-Level-3-Events/) 一致，无论你使用哪种浏览器。

完备的**合成事件系统，使得所有的事件对象都被保证符合W3C细则，并且所有事件在各个浏览器都一致并高效的冒泡**（bubbles）。

### 合成事件系统（重点）

React自己实现了一套高效的事件注册，存储，分发和重用逻辑，在DOM事件体系基础上做了很大改进，**减少了内存消耗，简化了事件逻辑，并最大化的解决了IE等浏览器的不兼容问题**。与DOM事件体系相比，它有如下特点：

1. **React组件上声明的事件最终绑定到了document这个DOM节点上，而不是React组件对应的DOM节点**。故**只有document这个节点上面才绑定了DOM原生事件，其他节点没有绑定事件**。这样**简化了DOM原生事件，减少了内存开销**

2. React以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。即：React自身实现了一套事件冒泡机制。我们没办法用event.stopPropagation()来停止事件传播，应该使用event.preventDefault()

3. React使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能

## （2）自动绑定和事件代理

在幕后，React的事件系统做了一些操作来让代码高效运行且易于理解。

**自动绑定**: 在 JS 里创建回调的时候，为了保证 this 的正确性，一般都需要显式地绑定方法到它的实例上。**在 React 中，所有方法被自动绑定到了它的组件实例上**（[除非使用ES6的class符号](http://www.react-cn.com/docs/reusable-components.html#no-autobinding)）。**React 还缓存这些绑定方法，所以 CPU 和内存都是非常高效**。而且还能减少打字！

**事件代理**: **React 并没有把事件处理器绑定到节点本身**。当 **React 启动时，会在最外层使用唯一一个事件监听器处理所有事件**。当组件被加载和卸载时，只是在内部映射里添加或删除事件处理器。当**事件触发，React 根据映射来决定如何分发**。当映射里没有事件处理函数时，会当作空操作处理。参考 [David Walsh 这篇很棒的文章](https://davidwalsh.name/event-delegate) 了解这样做高效的原因。

